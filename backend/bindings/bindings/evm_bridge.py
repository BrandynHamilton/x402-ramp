# This file was generated by stellar_contract_bindings v0.4.1b0 and stellar_sdk v12.3.0.

from __future__ import annotations

from enum import IntEnum, Enum
from typing import Dict, List, Tuple, Optional, Union

from stellar_sdk import scval, xdr, Address, MuxedAccount, Keypair
from stellar_sdk.contract import AssembledTransaction, ContractClient
from stellar_sdk.contract import AssembledTransactionAsync, ContractClientAsync

NULL_ACCOUNT = "GAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWHF"


class DataKeyKind(Enum):
    Admin = "Admin"
    EscrowNonce = "EscrowNonce"


class DataKey:
    def __init__(
        self,
        kind: DataKeyKind,
        escrow_nonce: Optional[Union[Address, str]] = None,
    ):
        self.kind = kind
        self.escrow_nonce = escrow_nonce

    def to_scval(self) -> xdr.SCVal:
        if self.kind == DataKeyKind.Admin:
            return scval.to_enum(self.kind.name, None)
        if self.kind == DataKeyKind.EscrowNonce:
            assert self.escrow_nonce is not None
            return scval.to_enum(self.kind.name, scval.to_address(self.escrow_nonce))
        raise ValueError(f"Invalid kind: {self.kind}")

    @classmethod
    def from_scval(cls, val: xdr.SCVal):
        elements = scval.from_enum(val)
        kind = DataKeyKind(elements[0])
        if kind == DataKeyKind.Admin:
            return cls(kind)
        if kind == DataKeyKind.EscrowNonce:
            assert elements[1] is not None and isinstance(elements[1], xdr.SCVal)
            return cls(kind, escrow_nonce=scval.from_address(elements[1]))
        raise ValueError(f"Invalid kind: {kind}")

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, DataKey):
            return NotImplemented
        if self.kind != other.kind:
            return False
        if self.kind == DataKeyKind.EscrowNonce:
            return self.escrow_nonce == other.escrow_nonce
        return True

    def __hash__(self) -> int:
        if self.kind == DataKeyKind.EscrowNonce:
            return hash((self.kind, self.escrow_nonce))
        return hash(self.kind)


class Escrow:
    amount: int
    evm_tx: bytes
    node: bytes
    status: str
    target_address: bytes
    user: Address

    def __init__(
        self,
        amount: int,
        evm_tx: bytes,
        node: bytes,
        status: str,
        target_address: bytes,
        user: Union[Address, str],
    ):
        self.amount = amount
        self.evm_tx = evm_tx
        self.node = node
        self.status = status
        self.target_address = target_address
        self.user = user

    def to_scval(self) -> xdr.SCVal:
        return scval.to_struct(
            {
                "amount": scval.to_int128(self.amount),
                "evm_tx": scval.to_string(self.evm_tx),
                "node": scval.to_string(self.node),
                "status": scval.to_symbol(self.status),
                "target_address": scval.to_bytes(self.target_address),
                "user": scval.to_address(self.user),
            }
        )

    @classmethod
    def from_scval(cls, val: xdr.SCVal):
        elements = scval.from_struct(val)
        return cls(
            scval.from_int128(elements["amount"]),
            scval.from_string(elements["evm_tx"]),
            scval.from_string(elements["node"]),
            scval.from_symbol(elements["status"]),
            scval.from_bytes(elements["target_address"]),
            scval.from_address(elements["user"]),
        )

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Escrow):
            return NotImplemented
        return (
            self.amount == other.amount
            and self.evm_tx == other.evm_tx
            and self.node == other.node
            and self.status == other.status
            and self.target_address == other.target_address
            and self.user == other.user
        )

    def __hash__(self) -> int:
        return hash(
            (
                self.amount,
                self.evm_tx,
                self.node,
                self.status,
                self.target_address,
                self.user,
            )
        )


class Error(IntEnum):
    AlreadyInitialized = 1
    AdminNotInitialized = 2
    EscrowNotFound = 3
    EscrowNotPending = 4
    EscrowNotProcessing = 5
    UnauthorizedRefund = 6
    InvalidAddressLength = 7
    InvalidAmount = 8

    def to_scval(self) -> xdr.SCVal:
        return scval.to_uint32(self.value)

    @classmethod
    def from_scval(cls, val: xdr.SCVal):
        return cls(scval.from_uint32(val))


class Client(ContractClient):
    def init(
        self,
        admin: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[None]:
        return self.invoke(
            "init",
            [scval.to_address(admin)],
            parse_result_xdr_fn=lambda _: None,
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def get_admin(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[Address]:
        return self.invoke(
            "get_admin",
            [],
            parse_result_xdr_fn=lambda v: scval.from_address(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def get_user_nonce(
        self,
        user: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[int]:
        return self.invoke(
            "get_user_nonce",
            [scval.to_address(user)],
            parse_result_xdr_fn=lambda v: scval.from_uint32(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def lock(
        self,
        token: Union[Address, str],
        user: Union[Address, str],
        amount: int,
        target_chain: int,
        target_address: bytes,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[bytes]:
        return self.invoke(
            "lock",
            [
                scval.to_address(token),
                scval.to_address(user),
                scval.to_int128(amount),
                scval.to_int128(target_chain),
                scval.to_bytes(target_address),
            ],
            parse_result_xdr_fn=lambda v: scval.from_bytes(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def get_escrow(
        self,
        id: bytes,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[Escrow]:
        return self.invoke(
            "get_escrow",
            [scval.to_bytes(id)],
            parse_result_xdr_fn=lambda v: Escrow.from_scval(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def get_escrow_status(
        self,
        id: bytes,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[str]:
        return self.invoke(
            "get_escrow_status",
            [scval.to_bytes(id)],
            parse_result_xdr_fn=lambda v: scval.from_symbol(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def process_escrow(
        self,
        id: bytes,
        node: bytes,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[None]:
        return self.invoke(
            "process_escrow",
            [scval.to_bytes(id), scval.to_string(node)],
            parse_result_xdr_fn=lambda _: None,
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def claim(
        self,
        id: bytes,
        token: Union[Address, str],
        evm_tx: bytes,
        claimer: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[None]:
        return self.invoke(
            "claim",
            [
                scval.to_bytes(id),
                scval.to_address(token),
                scval.to_string(evm_tx),
                scval.to_address(claimer),
            ],
            parse_result_xdr_fn=lambda _: None,
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def refund(
        self,
        id: bytes,
        token: Union[Address, str],
        user: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[None]:
        return self.invoke(
            "refund",
            [scval.to_bytes(id), scval.to_address(token), scval.to_address(user)],
            parse_result_xdr_fn=lambda _: None,
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )


class ClientAsync(ContractClientAsync):
    async def init(
        self,
        admin: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[None]:
        return await self.invoke(
            "init",
            [scval.to_address(admin)],
            parse_result_xdr_fn=lambda _: None,
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def get_admin(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[Address]:
        return await self.invoke(
            "get_admin",
            [],
            parse_result_xdr_fn=lambda v: scval.from_address(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def get_user_nonce(
        self,
        user: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[int]:
        return await self.invoke(
            "get_user_nonce",
            [scval.to_address(user)],
            parse_result_xdr_fn=lambda v: scval.from_uint32(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def lock(
        self,
        token: Union[Address, str],
        user: Union[Address, str],
        amount: int,
        target_chain: int,
        target_address: bytes,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[bytes]:
        return await self.invoke(
            "lock",
            [
                scval.to_address(token),
                scval.to_address(user),
                scval.to_int128(amount),
                scval.to_int128(target_chain),
                scval.to_bytes(target_address),
            ],
            parse_result_xdr_fn=lambda v: scval.from_bytes(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def get_escrow(
        self,
        id: bytes,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[Escrow]:
        return await self.invoke(
            "get_escrow",
            [scval.to_bytes(id)],
            parse_result_xdr_fn=lambda v: Escrow.from_scval(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def get_escrow_status(
        self,
        id: bytes,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[str]:
        return await self.invoke(
            "get_escrow_status",
            [scval.to_bytes(id)],
            parse_result_xdr_fn=lambda v: scval.from_symbol(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def process_escrow(
        self,
        id: bytes,
        node: bytes,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[None]:
        return await self.invoke(
            "process_escrow",
            [scval.to_bytes(id), scval.to_string(node)],
            parse_result_xdr_fn=lambda _: None,
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def claim(
        self,
        id: bytes,
        token: Union[Address, str],
        evm_tx: bytes,
        claimer: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[None]:
        return await self.invoke(
            "claim",
            [
                scval.to_bytes(id),
                scval.to_address(token),
                scval.to_string(evm_tx),
                scval.to_address(claimer),
            ],
            parse_result_xdr_fn=lambda _: None,
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def refund(
        self,
        id: bytes,
        token: Union[Address, str],
        user: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[None]:
        return await self.invoke(
            "refund",
            [scval.to_bytes(id), scval.to_address(token), scval.to_address(user)],
            parse_result_xdr_fn=lambda _: None,
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )
